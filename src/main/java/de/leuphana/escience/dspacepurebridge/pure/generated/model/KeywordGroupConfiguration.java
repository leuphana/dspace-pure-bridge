/*
 * Pure API
 * The Pure API provides a secure and complete web services API for using and managing research information data in Pure. The API enables a broad range of use-cases for interacting with research information, from anonymous Open Data scenarios to enabling the next generation Pure admin.
 *
 * The version of the OpenAPI document: 5.31.1-1
 * Contact: pure-support@elsevier.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.leuphana.escience.dspacepurebridge.pure.generated.model;

import com.google.gson.*;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import de.leuphana.escience.dspacepurebridge.pure.generated.JSON;
import org.openapitools.jackson.nullable.JsonNullable;

import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.*;

/**
 * A specification of the allowed behavior of a specified keyword group
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-11-21T15:48:42.574492757+01:00[Europe/Berlin]", comments = "Generator version: 7.10.0")
public class KeywordGroupConfiguration {
  public static final String SERIALIZED_NAME_PURE_ID = "pureId";
  @SerializedName(SERIALIZED_NAME_PURE_ID)
  @javax.annotation.Nullable
  private Long pureId;

  public static final String SERIALIZED_NAME_UUID = "uuid";
  @SerializedName(SERIALIZED_NAME_UUID)
  @javax.annotation.Nullable
  private UUID uuid;

  public static final String SERIALIZED_NAME_CREATED_BY = "createdBy";
  @SerializedName(SERIALIZED_NAME_CREATED_BY)
  @javax.annotation.Nullable
  private String createdBy;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  @javax.annotation.Nullable
  private OffsetDateTime createdDate;

  public static final String SERIALIZED_NAME_MODIFIED_BY = "modifiedBy";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY)
  @javax.annotation.Nullable
  private String modifiedBy;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  @javax.annotation.Nullable
  private OffsetDateTime modifiedDate;

  public static final String SERIALIZED_NAME_PORTAL_URL = "portalUrl";
  @SerializedName(SERIALIZED_NAME_PORTAL_URL)
  @javax.annotation.Nullable
  private String portalUrl;

  public static final String SERIALIZED_NAME_PRETTY_URL_IDENTIFIERS = "prettyUrlIdentifiers";
  @SerializedName(SERIALIZED_NAME_PRETTY_URL_IDENTIFIERS)
  @javax.annotation.Nullable
  private List<String> prettyUrlIdentifiers = new ArrayList<>();

  public static final String SERIALIZED_NAME_PREVIOUS_UUIDS = "previousUuids";
  @SerializedName(SERIALIZED_NAME_PREVIOUS_UUIDS)
  @javax.annotation.Nullable
  private List<String> previousUuids = new ArrayList<>();

  public static final String SERIALIZED_NAME_VERSION = "version";
  @SerializedName(SERIALIZED_NAME_VERSION)
  @javax.annotation.Nullable
  private String version;

  public static final String SERIALIZED_NAME_TARGET_SYSTEM_NAME = "targetSystemName";
  @SerializedName(SERIALIZED_NAME_TARGET_SYSTEM_NAME)
  @javax.annotation.Nonnull
  private String targetSystemName;

  public static final String SERIALIZED_NAME_KEYWORD_GROUP_TYPE = "keywordGroupType";
  @SerializedName(SERIALIZED_NAME_KEYWORD_GROUP_TYPE)
  @javax.annotation.Nullable
  private String keywordGroupType;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private Map<String, String> name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private Map<String, String> description;

  public static final String SERIALIZED_NAME_CLASSIFICATION_SCHEME = "classificationScheme";
  @SerializedName(SERIALIZED_NAME_CLASSIFICATION_SCHEME)
  @javax.annotation.Nullable
  private ContentRef classificationScheme;

  public static final String SERIALIZED_NAME_ALLOW_USERDEFINED_KEYWORDS = "allowUserdefinedKeywords";
  @SerializedName(SERIALIZED_NAME_ALLOW_USERDEFINED_KEYWORDS)
  @javax.annotation.Nullable
  private Boolean allowUserdefinedKeywords;

  public static final String SERIALIZED_NAME_LIMIT_TO_LEAF_SELECTION = "limitToLeafSelection";
  @SerializedName(SERIALIZED_NAME_LIMIT_TO_LEAF_SELECTION)
  @javax.annotation.Nullable
  private Boolean limitToLeafSelection;

  public static final String SERIALIZED_NAME_LOGICAL_NAME = "logicalName";
  @SerializedName(SERIALIZED_NAME_LOGICAL_NAME)
  @javax.annotation.Nonnull
  private String logicalName;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  @javax.annotation.Nonnull
  private Integer weight;

  public static final String SERIALIZED_NAME_MIN_AMOUNT_OF_KEYWORDS = "minAmountOfKeywords";
  @SerializedName(SERIALIZED_NAME_MIN_AMOUNT_OF_KEYWORDS)
  @javax.annotation.Nullable
  private Integer minAmountOfKeywords;

  public static final String SERIALIZED_NAME_MAX_AMOUNT_OF_KEYWORDS = "maxAmountOfKeywords";
  @SerializedName(SERIALIZED_NAME_MAX_AMOUNT_OF_KEYWORDS)
  @javax.annotation.Nullable
  private Integer maxAmountOfKeywords;

  public static final String SERIALIZED_NAME_MODIFYING_ROLES = "modifyingRoles";
  @SerializedName(SERIALIZED_NAME_MODIFYING_ROLES)
  @javax.annotation.Nullable
  private List<String> modifyingRoles;

  /**
   * User defined keyword edit mode
   */
  @JsonAdapter(UserdefinedKeywordEditModeEnum.Adapter.class)
  public enum UserdefinedKeywordEditModeEnum {
    SUBMISSION_LOCALE("SUBMISSION_LOCALE"),
    
    ALL_SUPPORTED_SUBMISSION_LOCALES("ALL_SUPPORTED_SUBMISSION_LOCALES"),
    
    ALL_SUPPORTED_LOCALES("ALL_SUPPORTED_LOCALES");

    private String value;

    UserdefinedKeywordEditModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static UserdefinedKeywordEditModeEnum fromValue(String value) {
      for (UserdefinedKeywordEditModeEnum b : UserdefinedKeywordEditModeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<UserdefinedKeywordEditModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UserdefinedKeywordEditModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UserdefinedKeywordEditModeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return UserdefinedKeywordEditModeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      UserdefinedKeywordEditModeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_USERDEFINED_KEYWORD_EDIT_MODE = "userdefinedKeywordEditMode";
  @SerializedName(SERIALIZED_NAME_USERDEFINED_KEYWORD_EDIT_MODE)
  @javax.annotation.Nullable
  private UserdefinedKeywordEditModeEnum userdefinedKeywordEditMode;

  /**
   * Select sorting order of in the selection mode
   */
  @JsonAdapter(SelectionModeSortingOrderEnum.Adapter.class)
  public enum SelectionModeSortingOrderEnum {
    ASCENDING("ASCENDING"),
    
    DESCENDING("DESCENDING"),
    
    SCHEMA_INDEX("SCHEMA_INDEX");

    private String value;

    SelectionModeSortingOrderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SelectionModeSortingOrderEnum fromValue(String value) {
      for (SelectionModeSortingOrderEnum b : SelectionModeSortingOrderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SelectionModeSortingOrderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SelectionModeSortingOrderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SelectionModeSortingOrderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SelectionModeSortingOrderEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SelectionModeSortingOrderEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SELECTION_MODE_SORTING_ORDER = "selectionModeSortingOrder";
  @SerializedName(SERIALIZED_NAME_SELECTION_MODE_SORTING_ORDER)
  @javax.annotation.Nullable
  private SelectionModeSortingOrderEnum selectionModeSortingOrder;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private List<String> tags = new ArrayList<>();

  public static final String SERIALIZED_NAME_RELATION_TYPE = "relationType";
  @SerializedName(SERIALIZED_NAME_RELATION_TYPE)
  @javax.annotation.Nullable
  private String relationType;

  public static final String SERIALIZED_NAME_SYSTEM_NAME = "systemName";
  @SerializedName(SERIALIZED_NAME_SYSTEM_NAME)
  @javax.annotation.Nullable
  private String systemName;

  public KeywordGroupConfiguration() {
  }

  public KeywordGroupConfiguration(
     Long pureId, 
     UUID uuid, 
     String createdBy, 
     OffsetDateTime createdDate, 
     String modifiedBy, 
     OffsetDateTime modifiedDate, 
     String portalUrl, 
     List<String> prettyUrlIdentifiers, 
     List<String> previousUuids, 
     String keywordGroupType, 
     String systemName
  ) {
    this();
    this.pureId = pureId;
    this.uuid = uuid;
    this.createdBy = createdBy;
    this.createdDate = createdDate;
    this.modifiedBy = modifiedBy;
    this.modifiedDate = modifiedDate;
    this.portalUrl = portalUrl;
    this.prettyUrlIdentifiers = prettyUrlIdentifiers;
    this.previousUuids = previousUuids;
    this.keywordGroupType = keywordGroupType;
    this.systemName = systemName;
  }

  /**
   * Pure database ID of the object, prefer using the UUID if it is present on the entity
   * @return pureId
   */
  @javax.annotation.Nullable
  public Long getPureId() {
    return pureId;
  }



  /**
   * UUID, this is the primary identity of the entity
   * @return uuid
   */
  @javax.annotation.Nullable
  public UUID getUuid() {
    return uuid;
  }



  /**
   * Username of creator
   * @return createdBy
   */
  @javax.annotation.Nullable
  public String getCreatedBy() {
    return createdBy;
  }



  /**
   * Date and time of creation
   * @return createdDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedDate() {
    return createdDate;
  }



  /**
   * Username of the user that performed a modification
   * @return modifiedBy
   */
  @javax.annotation.Nullable
  public String getModifiedBy() {
    return modifiedBy;
  }



  /**
   * Date and time of last modification
   * @return modifiedDate
   */
  @javax.annotation.Nullable
  public OffsetDateTime getModifiedDate() {
    return modifiedDate;
  }



  /**
   * URL of the content on the Pure Portal
   * @return portalUrl
   */
  @javax.annotation.Nullable
  public String getPortalUrl() {
    return portalUrl;
  }



  /**
   * All pretty URLs
   * @return prettyUrlIdentifiers
   */
  @javax.annotation.Nullable
  public List<String> getPrettyUrlIdentifiers() {
    return prettyUrlIdentifiers;
  }



  /**
   * UUIDs of other content items which have been merged into this content item (or similar)
   * @return previousUuids
   */
  @javax.annotation.Nullable
  public List<String> getPreviousUuids() {
    return previousUuids;
  }



  public KeywordGroupConfiguration version(@javax.annotation.Nullable String version) {
    this.version = version;
    return this;
  }

  /**
   * Used to guard against conflicting updates. For new content this is null, and for existing content the current value. The property should never be modified by a client, except in the rare case where the client wants to perform an update irrespective of if other clients have made updates in the meantime, also known as a \&quot;dirty write\&quot;. A dirty write is performed by not including the property value or setting the property to null
   * @return version
   */
  @javax.annotation.Nullable
  public String getVersion() {
    return version;
  }

  public void setVersion(@javax.annotation.Nullable String version) {
    this.version = version;
  }


  public KeywordGroupConfiguration targetSystemName(@javax.annotation.Nonnull String targetSystemName) {
    this.targetSystemName = targetSystemName;
    return this;
  }

  /**
   * The content system name this configuration applies to
   * @return targetSystemName
   */
  @javax.annotation.Nonnull
  public String getTargetSystemName() {
    return targetSystemName;
  }

  public void setTargetSystemName(@javax.annotation.Nonnull String targetSystemName) {
    this.targetSystemName = targetSystemName;
  }


  /**
   * The OpenAPI schema type of this keyword configuration
   * @return keywordGroupType
   */
  @javax.annotation.Nullable
  public String getKeywordGroupType() {
    return keywordGroupType;
  }



  public KeywordGroupConfiguration name(@javax.annotation.Nullable Map<String, String> name) {
    this.name = name;
    return this;
  }

  public KeywordGroupConfiguration putNameItem(String key, String nameItem) {
    if (this.name == null) {
      this.name = new HashMap<>();
    }
    this.name.put(key, nameItem);
    return this;
  }

  /**
   * A set of string values, one for each submission locale. Note: invalid locale values will be ignored.
   * @return name
   */
  @javax.annotation.Nullable
  public Map<String, String> getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable Map<String, String> name) {
    this.name = name;
  }


  public KeywordGroupConfiguration description(@javax.annotation.Nullable Map<String, String> description) {
    this.description = description;
    return this;
  }

  public KeywordGroupConfiguration putDescriptionItem(String key, String descriptionItem) {
    if (this.description == null) {
      this.description = new HashMap<>();
    }
    this.description.put(key, descriptionItem);
    return this;
  }

  /**
   * A set of localized strings that support formatting. Invalid locale values will be ignored.
   * @return description
   */
  @javax.annotation.Nullable
  public Map<String, String> getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable Map<String, String> description) {
    this.description = description;
  }


  public KeywordGroupConfiguration classificationScheme(@javax.annotation.Nullable ContentRef classificationScheme) {
    this.classificationScheme = classificationScheme;
    return this;
  }

  /**
   * A reference to a classification scheme
   * @return classificationScheme
   */
  @javax.annotation.Nullable
  public ContentRef getClassificationScheme() {
    return classificationScheme;
  }

  public void setClassificationScheme(@javax.annotation.Nullable ContentRef classificationScheme) {
    this.classificationScheme = classificationScheme;
  }


  public KeywordGroupConfiguration allowUserdefinedKeywords(@javax.annotation.Nullable Boolean allowUserdefinedKeywords) {
    this.allowUserdefinedKeywords = allowUserdefinedKeywords;
    return this;
  }

  /**
   * Defines if user defined keywords are allowed
   * @return allowUserdefinedKeywords
   */
  @javax.annotation.Nullable
  public Boolean getAllowUserdefinedKeywords() {
    return allowUserdefinedKeywords;
  }

  public void setAllowUserdefinedKeywords(@javax.annotation.Nullable Boolean allowUserdefinedKeywords) {
    this.allowUserdefinedKeywords = allowUserdefinedKeywords;
  }


  public KeywordGroupConfiguration limitToLeafSelection(@javax.annotation.Nullable Boolean limitToLeafSelection) {
    this.limitToLeafSelection = limitToLeafSelection;
    return this;
  }

  /**
   * Defines if selection of classifications is limited to leafs or also intermediate nodes
   * @return limitToLeafSelection
   */
  @javax.annotation.Nullable
  public Boolean getLimitToLeafSelection() {
    return limitToLeafSelection;
  }

  public void setLimitToLeafSelection(@javax.annotation.Nullable Boolean limitToLeafSelection) {
    this.limitToLeafSelection = limitToLeafSelection;
  }


  public KeywordGroupConfiguration logicalName(@javax.annotation.Nonnull String logicalName) {
    this.logicalName = logicalName;
    return this;
  }

  /**
   * Defines a logical name for the group that makes it easy to find
   * @return logicalName
   */
  @javax.annotation.Nonnull
  public String getLogicalName() {
    return logicalName;
  }

  public void setLogicalName(@javax.annotation.Nonnull String logicalName) {
    this.logicalName = logicalName;
  }


  public KeywordGroupConfiguration weight(@javax.annotation.Nonnull Integer weight) {
    this.weight = weight;
    return this;
  }

  /**
   * Used to order keyword group configurations for the target family. Keyword groups will also be ordered in the contexts they appear in. The kKeyword group configuration with the highest weight value comes first.
   * @return weight
   */
  @javax.annotation.Nonnull
  public Integer getWeight() {
    return weight;
  }

  public void setWeight(@javax.annotation.Nonnull Integer weight) {
    this.weight = weight;
  }


  public KeywordGroupConfiguration minAmountOfKeywords(@javax.annotation.Nullable Integer minAmountOfKeywords) {
    this.minAmountOfKeywords = minAmountOfKeywords;
    return this;
  }

  /**
   * Used to set the minimum amount of keywords that has to be chosen from this keyword group
   * @return minAmountOfKeywords
   */
  @javax.annotation.Nullable
  public Integer getMinAmountOfKeywords() {
    return minAmountOfKeywords;
  }

  public void setMinAmountOfKeywords(@javax.annotation.Nullable Integer minAmountOfKeywords) {
    this.minAmountOfKeywords = minAmountOfKeywords;
  }


  public KeywordGroupConfiguration maxAmountOfKeywords(@javax.annotation.Nullable Integer maxAmountOfKeywords) {
    this.maxAmountOfKeywords = maxAmountOfKeywords;
    return this;
  }

  /**
   * Used to set the maximum amount of keywords that can to be chosen from this keyword group
   * @return maxAmountOfKeywords
   */
  @javax.annotation.Nullable
  public Integer getMaxAmountOfKeywords() {
    return maxAmountOfKeywords;
  }

  public void setMaxAmountOfKeywords(@javax.annotation.Nullable Integer maxAmountOfKeywords) {
    this.maxAmountOfKeywords = maxAmountOfKeywords;
  }


  public KeywordGroupConfiguration modifyingRoles(@javax.annotation.Nullable List<String> modifyingRoles) {
    this.modifyingRoles = modifyingRoles;
    return this;
  }

  public KeywordGroupConfiguration addModifyingRolesItem(String modifyingRolesItem) {
    if (this.modifyingRoles == null) {
      this.modifyingRoles = new ArrayList<>();
    }
    this.modifyingRoles.add(modifyingRolesItem);
    return this;
  }

  /**
   * List of roles that may modify this keyword group where it is in use on some content. An empty set indicates there is no limit on which roles may edit the group
   * @return modifyingRoles
   */
  @javax.annotation.Nullable
  public List<String> getModifyingRoles() {
    return modifyingRoles;
  }

  public void setModifyingRoles(@javax.annotation.Nullable List<String> modifyingRoles) {
    this.modifyingRoles = modifyingRoles;
  }


  public KeywordGroupConfiguration userdefinedKeywordEditMode(@javax.annotation.Nullable UserdefinedKeywordEditModeEnum userdefinedKeywordEditMode) {
    this.userdefinedKeywordEditMode = userdefinedKeywordEditMode;
    return this;
  }

  /**
   * User defined keyword edit mode
   * @return userdefinedKeywordEditMode
   */
  @javax.annotation.Nullable
  public UserdefinedKeywordEditModeEnum getUserdefinedKeywordEditMode() {
    return userdefinedKeywordEditMode;
  }

  public void setUserdefinedKeywordEditMode(@javax.annotation.Nullable UserdefinedKeywordEditModeEnum userdefinedKeywordEditMode) {
    this.userdefinedKeywordEditMode = userdefinedKeywordEditMode;
  }


  public KeywordGroupConfiguration selectionModeSortingOrder(@javax.annotation.Nullable SelectionModeSortingOrderEnum selectionModeSortingOrder) {
    this.selectionModeSortingOrder = selectionModeSortingOrder;
    return this;
  }

  /**
   * Select sorting order of in the selection mode
   * @return selectionModeSortingOrder
   */
  @javax.annotation.Nullable
  public SelectionModeSortingOrderEnum getSelectionModeSortingOrder() {
    return selectionModeSortingOrder;
  }

  public void setSelectionModeSortingOrder(@javax.annotation.Nullable SelectionModeSortingOrderEnum selectionModeSortingOrder) {
    this.selectionModeSortingOrder = selectionModeSortingOrder;
  }


  public KeywordGroupConfiguration tags(@javax.annotation.Nullable List<String> tags) {
    this.tags = tags;
    return this;
  }

  public KeywordGroupConfiguration addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

  /**
   * A list of tags that can be used to identify this group. Any string can be used as a tag, but there are a few strings that have a special interpretation: 1) &#39;visible-on-portal&#39; - keywords are shown in the portal, 2) &#39;visible-in-ws&#39; - keywords are accessible through the web service, 3) &#39;visible-in-long-renderers&#39; - keywords are shown in long renderings of content, 4) &#39;show-filter-on-portal&#39; - there will be a filter option for keywords of this group on the portal.
   * @return tags
   */
  @javax.annotation.Nullable
  public List<String> getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable List<String> tags) {
    this.tags = tags;
  }


  public KeywordGroupConfiguration relationType(@javax.annotation.Nullable String relationType) {
    this.relationType = relationType;
    return this;
  }

  /**
   * The schema name of the type (with the ability to associate keywords) on which the keyword group configuration is related to, e.g. StaffOrganizationAssociation. It can also be set to null (default value), which means the keyword group configuration is related to the main type (the target system name) and not a relation of the main type.
   * @return relationType
   */
  @javax.annotation.Nullable
  public String getRelationType() {
    return relationType;
  }

  public void setRelationType(@javax.annotation.Nullable String relationType) {
    this.relationType = relationType;
  }


  /**
   * The content system name
   * @return systemName
   */
  @javax.annotation.Nullable
  public String getSystemName() {
    return systemName;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    KeywordGroupConfiguration keywordGroupConfiguration = (KeywordGroupConfiguration) o;
    return Objects.equals(this.pureId, keywordGroupConfiguration.pureId) &&
        Objects.equals(this.uuid, keywordGroupConfiguration.uuid) &&
        Objects.equals(this.createdBy, keywordGroupConfiguration.createdBy) &&
        Objects.equals(this.createdDate, keywordGroupConfiguration.createdDate) &&
        Objects.equals(this.modifiedBy, keywordGroupConfiguration.modifiedBy) &&
        Objects.equals(this.modifiedDate, keywordGroupConfiguration.modifiedDate) &&
        Objects.equals(this.portalUrl, keywordGroupConfiguration.portalUrl) &&
        Objects.equals(this.prettyUrlIdentifiers, keywordGroupConfiguration.prettyUrlIdentifiers) &&
        Objects.equals(this.previousUuids, keywordGroupConfiguration.previousUuids) &&
        Objects.equals(this.version, keywordGroupConfiguration.version) &&
        Objects.equals(this.targetSystemName, keywordGroupConfiguration.targetSystemName) &&
        Objects.equals(this.keywordGroupType, keywordGroupConfiguration.keywordGroupType) &&
        Objects.equals(this.name, keywordGroupConfiguration.name) &&
        Objects.equals(this.description, keywordGroupConfiguration.description) &&
        Objects.equals(this.classificationScheme, keywordGroupConfiguration.classificationScheme) &&
        Objects.equals(this.allowUserdefinedKeywords, keywordGroupConfiguration.allowUserdefinedKeywords) &&
        Objects.equals(this.limitToLeafSelection, keywordGroupConfiguration.limitToLeafSelection) &&
        Objects.equals(this.logicalName, keywordGroupConfiguration.logicalName) &&
        Objects.equals(this.weight, keywordGroupConfiguration.weight) &&
        Objects.equals(this.minAmountOfKeywords, keywordGroupConfiguration.minAmountOfKeywords) &&
        Objects.equals(this.maxAmountOfKeywords, keywordGroupConfiguration.maxAmountOfKeywords) &&
        Objects.equals(this.modifyingRoles, keywordGroupConfiguration.modifyingRoles) &&
        Objects.equals(this.userdefinedKeywordEditMode, keywordGroupConfiguration.userdefinedKeywordEditMode) &&
        Objects.equals(this.selectionModeSortingOrder, keywordGroupConfiguration.selectionModeSortingOrder) &&
        Objects.equals(this.tags, keywordGroupConfiguration.tags) &&
        Objects.equals(this.relationType, keywordGroupConfiguration.relationType) &&
        Objects.equals(this.systemName, keywordGroupConfiguration.systemName);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(pureId, uuid, createdBy, createdDate, modifiedBy, modifiedDate, portalUrl, prettyUrlIdentifiers, previousUuids, version, targetSystemName, keywordGroupType, name, description, classificationScheme, allowUserdefinedKeywords, limitToLeafSelection, logicalName, weight, minAmountOfKeywords, maxAmountOfKeywords, modifyingRoles, userdefinedKeywordEditMode, selectionModeSortingOrder, tags, relationType, systemName);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class KeywordGroupConfiguration {\n");
    sb.append("    pureId: ").append(toIndentedString(pureId)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    modifiedBy: ").append(toIndentedString(modifiedBy)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    portalUrl: ").append(toIndentedString(portalUrl)).append("\n");
    sb.append("    prettyUrlIdentifiers: ").append(toIndentedString(prettyUrlIdentifiers)).append("\n");
    sb.append("    previousUuids: ").append(toIndentedString(previousUuids)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    targetSystemName: ").append(toIndentedString(targetSystemName)).append("\n");
    sb.append("    keywordGroupType: ").append(toIndentedString(keywordGroupType)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    classificationScheme: ").append(toIndentedString(classificationScheme)).append("\n");
    sb.append("    allowUserdefinedKeywords: ").append(toIndentedString(allowUserdefinedKeywords)).append("\n");
    sb.append("    limitToLeafSelection: ").append(toIndentedString(limitToLeafSelection)).append("\n");
    sb.append("    logicalName: ").append(toIndentedString(logicalName)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("    minAmountOfKeywords: ").append(toIndentedString(minAmountOfKeywords)).append("\n");
    sb.append("    maxAmountOfKeywords: ").append(toIndentedString(maxAmountOfKeywords)).append("\n");
    sb.append("    modifyingRoles: ").append(toIndentedString(modifyingRoles)).append("\n");
    sb.append("    userdefinedKeywordEditMode: ").append(toIndentedString(userdefinedKeywordEditMode)).append("\n");
    sb.append("    selectionModeSortingOrder: ").append(toIndentedString(selectionModeSortingOrder)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    relationType: ").append(toIndentedString(relationType)).append("\n");
    sb.append("    systemName: ").append(toIndentedString(systemName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("pureId");
    openapiFields.add("uuid");
    openapiFields.add("createdBy");
    openapiFields.add("createdDate");
    openapiFields.add("modifiedBy");
    openapiFields.add("modifiedDate");
    openapiFields.add("portalUrl");
    openapiFields.add("prettyUrlIdentifiers");
    openapiFields.add("previousUuids");
    openapiFields.add("version");
    openapiFields.add("targetSystemName");
    openapiFields.add("keywordGroupType");
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("classificationScheme");
    openapiFields.add("allowUserdefinedKeywords");
    openapiFields.add("limitToLeafSelection");
    openapiFields.add("logicalName");
    openapiFields.add("weight");
    openapiFields.add("minAmountOfKeywords");
    openapiFields.add("maxAmountOfKeywords");
    openapiFields.add("modifyingRoles");
    openapiFields.add("userdefinedKeywordEditMode");
    openapiFields.add("selectionModeSortingOrder");
    openapiFields.add("tags");
    openapiFields.add("relationType");
    openapiFields.add("systemName");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("targetSystemName");
    openapiRequiredFields.add("logicalName");
    openapiRequiredFields.add("weight");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to KeywordGroupConfiguration
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!KeywordGroupConfiguration.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in KeywordGroupConfiguration is not found in the empty JSON string", KeywordGroupConfiguration.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!KeywordGroupConfiguration.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `KeywordGroupConfiguration` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : KeywordGroupConfiguration.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("uuid") != null && !jsonObj.get("uuid").isJsonNull()) && !jsonObj.get("uuid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `uuid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("uuid").toString()));
      }
      if ((jsonObj.get("createdBy") != null && !jsonObj.get("createdBy").isJsonNull()) && !jsonObj.get("createdBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdBy").toString()));
      }
      if ((jsonObj.get("modifiedBy") != null && !jsonObj.get("modifiedBy").isJsonNull()) && !jsonObj.get("modifiedBy").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifiedBy` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modifiedBy").toString()));
      }
      if ((jsonObj.get("portalUrl") != null && !jsonObj.get("portalUrl").isJsonNull()) && !jsonObj.get("portalUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `portalUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("portalUrl").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("prettyUrlIdentifiers") != null && !jsonObj.get("prettyUrlIdentifiers").isJsonNull() && !jsonObj.get("prettyUrlIdentifiers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `prettyUrlIdentifiers` to be an array in the JSON string but got `%s`", jsonObj.get("prettyUrlIdentifiers").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("previousUuids") != null && !jsonObj.get("previousUuids").isJsonNull() && !jsonObj.get("previousUuids").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `previousUuids` to be an array in the JSON string but got `%s`", jsonObj.get("previousUuids").toString()));
      }
      if ((jsonObj.get("version") != null && !jsonObj.get("version").isJsonNull()) && !jsonObj.get("version").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `version` to be a primitive type in the JSON string but got `%s`", jsonObj.get("version").toString()));
      }
      if (!jsonObj.get("targetSystemName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `targetSystemName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("targetSystemName").toString()));
      }
      if ((jsonObj.get("keywordGroupType") != null && !jsonObj.get("keywordGroupType").isJsonNull()) && !jsonObj.get("keywordGroupType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `keywordGroupType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("keywordGroupType").toString()));
      }
      // validate the optional field `classificationScheme`
      if (jsonObj.get("classificationScheme") != null && !jsonObj.get("classificationScheme").isJsonNull()) {
        ContentRef.validateJsonElement(jsonObj.get("classificationScheme"));
      }
      if (!jsonObj.get("logicalName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logicalName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logicalName").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("modifyingRoles") != null && !jsonObj.get("modifyingRoles").isJsonNull() && !jsonObj.get("modifyingRoles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifyingRoles` to be an array in the JSON string but got `%s`", jsonObj.get("modifyingRoles").toString()));
      }
      if ((jsonObj.get("userdefinedKeywordEditMode") != null && !jsonObj.get("userdefinedKeywordEditMode").isJsonNull()) && !jsonObj.get("userdefinedKeywordEditMode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userdefinedKeywordEditMode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userdefinedKeywordEditMode").toString()));
      }
      // validate the optional field `userdefinedKeywordEditMode`
      if (jsonObj.get("userdefinedKeywordEditMode") != null && !jsonObj.get("userdefinedKeywordEditMode").isJsonNull()) {
        UserdefinedKeywordEditModeEnum.validateJsonElement(jsonObj.get("userdefinedKeywordEditMode"));
      }
      if ((jsonObj.get("selectionModeSortingOrder") != null && !jsonObj.get("selectionModeSortingOrder").isJsonNull()) && !jsonObj.get("selectionModeSortingOrder").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selectionModeSortingOrder` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selectionModeSortingOrder").toString()));
      }
      // validate the optional field `selectionModeSortingOrder`
      if (jsonObj.get("selectionModeSortingOrder") != null && !jsonObj.get("selectionModeSortingOrder").isJsonNull()) {
        SelectionModeSortingOrderEnum.validateJsonElement(jsonObj.get("selectionModeSortingOrder"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("tags") != null && !jsonObj.get("tags").isJsonNull() && !jsonObj.get("tags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `tags` to be an array in the JSON string but got `%s`", jsonObj.get("tags").toString()));
      }
      if ((jsonObj.get("relationType") != null && !jsonObj.get("relationType").isJsonNull()) && !jsonObj.get("relationType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `relationType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("relationType").toString()));
      }
      if ((jsonObj.get("systemName") != null && !jsonObj.get("systemName").isJsonNull()) && !jsonObj.get("systemName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `systemName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("systemName").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!KeywordGroupConfiguration.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'KeywordGroupConfiguration' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<KeywordGroupConfiguration> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(KeywordGroupConfiguration.class));

       return (TypeAdapter<T>) new TypeAdapter<KeywordGroupConfiguration>() {
           @Override
           public void write(JsonWriter out, KeywordGroupConfiguration value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public KeywordGroupConfiguration read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of KeywordGroupConfiguration given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of KeywordGroupConfiguration
   * @throws IOException if the JSON string is invalid with respect to KeywordGroupConfiguration
   */
  public static KeywordGroupConfiguration fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, KeywordGroupConfiguration.class);
  }

  /**
   * Convert an instance of KeywordGroupConfiguration to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

